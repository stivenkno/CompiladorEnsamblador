# Recursive Fibonacci function
# Arguments: a0 = n
# Returns: a0 = fib(n)
fib:
    addi sp, sp, -8       # Allocate stack space
    sw ra, 4(sp)          # Save return address
    sw a0, 0(sp)          # Save n

    li t0, 2              # Check if n < 2
    blt a0, t0, base_case # If n < 2, base case

    addi a0, a0, -1       # fib(n-1)
    jal ra, fib           # Recursive call
    sw a0, 0(sp)          # Save fib(n-1)

    lw a0, 0(sp)          # Load saved n
    addi a0, a0, -2       # fib(n-2)
    jal ra, fib           # Recursive call

    lw t0, 0(sp)          # Load fib(n-1)
    add a0, a0, t0        # fib(n) = fib(n-1) + fib(n-2)
    j fib_return

base_case:
    li t0, 1
    blt a0, t0, return_zero
    li a0, 1              # fib(1) = 1
    j fib_return
return_zero:
    li a0, 0              # fib(0) or negative = 0

fib_return:
    lw ra, 4(sp)          # Restore ra
    addi sp, sp, 8        # Free stack
    jalr zero, 0(ra)      # Return (reemplaza 'ret')

# Program Entry Point
_start:
    li a0, 10             # fib(10)
    jal ra, fib           # Call fib

    # Exit program (con ecall soportado)
    li a7, 93             # syscall for exit
    ecall